={start} 성능 튜닝 시작하기
이 장에서는 성능 튜닝을 진행하기 위해 필요한 사전 준비와 작업 흐름에 대해 설명합니다. 

먼저 성능 튜닝을 시작하기 전에 결정해야 할 사항과 고려해야 할 사항들을 다룹니다. 
프로젝트가 아직 초기 단계에 있다면 꼭 읽어보시기 바랍니다. 
프로젝트가 어느 정도 진행되었다 하더라도, 이 내용을 고려하고 있는지 다시 한 번 확인하는 것이 좋습니다. 
다음으로 성능 저하가 발생한 애플리케이션에 대해 어떻게 대처해야 하는지에 대해 설명한다. 
원인 파악과 해결 방법을 익히면 성능 튜닝의 일련의 흐름을 실천할 수 있게 될 것이다. 

=={start_ready} 사전 준비
성능 튜닝에 앞서 달성하고자 하는 지표를 정해야 한다. 말로는 쉽지만 실제로는 매우 어려운 작업입니다. 
세상에는 다양한 사양의 단말기가 넘쳐나고, 저사양 단말기를 사용하는 사용자를 무시할 수 없기 때문이다. 
이런 상황에서 게임 사양, 타깃 유저층, 해외 진출 여부 등 여러 가지를 고려해야 한다. 
이 작업은 엔지니어 혼자서만 할 수 있는 일이 아니다. 다른 직종과 협의해 품질 기준을 정해야 하고, 기술 검증도 필요할 것이다. 

이러한 지표들은 부하를 측정할 만큼의 기능 구현이나 자산이 존재하지 않는 초기 단계부터 결정하기에는 어려움이 많습니다. 
따라서 프로젝트가 어느 정도 진행된 후에 결정하는 것도 하나의 방법이다. 
단, 프로젝트가 @<em>{양산 단계에 들어가기 전까지는 반드시 결정해야} 합니다. 
일단 양산을 시작하면 변경 비용이 엄청나게 커질 수 있기 때문입니다. 
본 절에서 소개하는 지표를 결정하는 데는 시간이 걸리겠지만, 서두르지 말고 차근차근 진행하도록 하자. 

====[column] 양산 단계 이후 사양 변경의 무서움

지금 양산 단계에 접어들었지만, 저사양 단말에서 드로잉에 병목현상이 발생하는 프로젝트가 있다고 가정해 봅시다. 
메모리는 이미 한계에 가까워서 거리에 따라 저부하 모델로 전환하는 방법도 사용할 수 없습니다. 
그래서 모델의 버텍스 수를 줄이기로 했습니다. 

우선 데이터를 리덕션하기 위해 데이터를 다시 주문합니다. 새로운 발주서가 필요할 것입니다. 
다음으로 디렉터가 품질을 다시 점검해야 합니다. 그리고 마지막으로 디버깅을 해야 합니다. 
단순하게 썼지만, 실제로는 더 세세한 작업과 일정 조정이 있을 것입니다. 

위와 같은 대응이 필요한 애셋이 양산 이후에도 수십~수백 개는 될 것입니다. 
이는 시간과 노력이 많이 소요되기 때문에 프로젝트에 치명적일 수 있습니다. 

이를 방지하기 위해 @<em>{가장 부하가 많이 걸리는 씬을 만들어} 지표를 충족하는지 @<em>{미리 검증하는 것이} 매우 중요합니다. 

====[/column]

==={start_ready_objective} 지표 결정하기
지표를 정하면 목표가 정해집니다. 반대로 지표가 없으면 언제까지나 끝이 없습니다. 
@<table>{table_object_tuning}에 결정하면 좋은 지표를 소개합니다. 
//table[table_object_tuning][지표]{
항목	요소
-------------------- 
프레임 속도		항상 어느 정도의 프레임 속도를 목표로 할 것인가?
메모리	어느 화면에서 메모리가 최대가 되는지 계산하여 한계치를 결정합니다.
전환 시간	트랜지션 시간 대기 시간은 어느 정도가 적절한가?
발열	연속 플레이 X시간 동안 어느 정도의 열을 견딜 수 있는가?
배터리	연속 플레이 X 시간 동안 배터리 소모가 허용되는 배터리 소모량
//}

@<table>{table_object_tuning}이 중에서 특히 @<em>{프레임 속도와}@<em>{메모리는} 중요한 지표이므로 반드시 결정해야 한다. 
이쯤에서 저사양 단말기는 잠시 접어두자. 
우선 볼륨존에 있는 단말기에 대한 지표를 정하는 것이 중요합니다. 

//info{
볼륨 존의 정의는 프로젝트에 따라 다릅니다. 
벤치마크가 될 다른 타이틀이나 시장 조사를 통해 결정하는 것도 좋습니다. 
혹은 모바일 기기의 교체가 장기화된 상황에서 4년 정도 전의 미들 레인지를 일단 지표로 삼을 수도 있습니다. 
근거가 조금 모호하더라도 목표로 삼아야 할 깃발을 세우세요. 거기서부터 조정해 나가면 됩니다. 
//}

여기서 실례를 생각해 봅시다. 
지금 다음과 같은 목표를 설정한 프로젝트가 있다고 가정해 봅시다. 

 * 경쟁 애플리케이션의 안 좋은 점을 모두 개선하고 싶다.
 * 특히 인게임을 매끄럽게 만들고 싶다.
 * 위의 사항 외에는 경쟁사와 동등하게 하고 싶다.

이 모호한 목표를 팀원들과 함께 언어화하니 다음과 같은 지표가 나왔다. 

 * 프레임 속도
 ** 인게임은 60프레임, 아웃게임은 배터리 소모 측면에서 30프레임으로 한다.
 * 메모리
 ** 전환 시간 단축을 위해 인게임 중에도 아웃게임의 일부 리소스를 유지하도록 설계한다. 최대 사용량을 1GB로 한다.
 * 전환 시간
 ** 인게임과 아웃게임으로의 전환 시간은 경쟁사와 동일한 수준을 목표로 한다. 시간으로 환산하면 3초 이내.
 * 열
 ** 경쟁사와 동일한 수준. 검증 단말기에서 1시간 연속으로 뜨거워지지 않음. (충전하지 않은 상태)
 * 배터리
 ** 경쟁사와 동일한 수준. 검증 단말에서 1시간 연속 사용 시 배터리 소모량은 20% 정도.

이렇게 목표로 삼을 지표가 정해지면 기준 단말기로 만져보자. 
전혀 목표에 도달하지 못하는 상태가 아니라면 지표로 삼을 만하다. 

====[column] 게임 장르별 최적화

이번에는 부드러운 움직임이 주제였기 때문에 프레임 속도를 60프레임으로 설정했습니다. 
그 외에도 리듬 액션 게임이나 FPS(1인칭 슈팅 게임)와 같이 판단이 중요한 게임도 높은 프레임 속도가 바람직할 것입니다. 
하지만 높은 프레임 레이트는 단점도 있습니다. 프레임이 높을수록 배터리를 많이 소모한다는 것이다. 
또 메모리는 사용량이 많을수록 일시정지 시 OS로부터 킬을 당하기 쉽다. 
이러한 장단점을 고려하여 게임 장르별로 적절한 목표를 정해야 합니다. 

====[/column]

==={start_ready_memory} 메모리 최대 사용량 파악하기
이 절에서는 최대 메모리 사용량에 대해 알아보자. 
최대 메모리 사용량을 알기 위해서는 우선 지원 대상 기기가 얼마나 많은 메모리를 확보할 수 있는지를 파악해야 합니다. 
기본적으로 동작을 보장하는 단말기 중 가장 낮은 사양의 단말기에서 검증하는 것이 좋습니다. 
단, OS 버전에 따라 메모리 확보 구조가 변경되었을 가능성이 있으므로, 가급적이면 메이저 버전이 다른 단말기를 여러 개 준비하는 것이 좋습니다. 
또한, 측정하는 툴에 따라 측정 로직이 다르기 때문에 사용하는 툴은 반드시 한 가지로 한정하는 것이 좋다. 

참고로 필자가 iOS에서 검증한 내용을 기재합니다. 
검증 프로젝트에서는 Texture2D를 런타임에 생성하여 얼마나 오래 걸리는지 측정했습니다. 
코드는 다음과 같습니다. 
//listnum[texture_leak][검증 코드][csharp]{
private List<Texture2D> _textureList = new List<Texture2D>();
...
public void CreateTexture(int size) {
	Texture2D texture = new Texture2D(size, size, TextureFormat.RGBA32, false);
	_textureList.Add(texture);
}
//}


검증 결과는 @<img>{memory_crash_ios}과 같습니다. 
//image[memory_crash_ios][크래시 임계값]

검증 환경은 Unity 2019.4.3, Xcode 11.6을 사용하였으며, Xcode의 Debug Navigator의 Memory 섹션의 수치를 참고하였습니다. 
이 검증 결과를 보면, 아이폰6S나 아이폰7과 같은 2GB의 메모리를 탑재한 단말기는 1.3GB 이내로 메모리를 확보하는 것이 좋다고 할 수 있다. 
또한, 아이폰6와 같은 1GB 메모리를 지원하는 단말기의 경우, 메모리 사용량의 제약이 상당히 심해지는 것을 알 수 있다. 
또 다른 특징은 iOS11의 경우 메모리 관리 구조가 달라서인지 메모리 사용량이 두드러진다는 점이다. 
검증할 때 이런 OS에 따른 차이는 드물다는 점을 참고하시기 바랍니다. 

//info{
@<img>{memory_crash_ios}에서는 검증 환경이 조금 오래되었기 때문에 작성 시점의 최신 환경으로 일부 재측정해 보았습니다. 
환경은 Unity 2020.3.25, 2021.2.0 2가지 버전과 Xcode 13.3.1을 사용하여 OS 버전이 14.6과 15.4.1인 아이폰XR에 빌드했다. 
그 결과 측정값에 별다른 차이를 보이지 않았기 때문에 아직은 신뢰할 수 있는 데이터라고 생각됩니다. 
//}

====[column] 메모리 측정 도구

측정하는 도구로 추천하고 싶은 것은 Xcode나 AndroidStudio와 같은 네이티브 호환 도구입니다. 
예를 들어 Unity Profiler의 측정에서는 플러그인 등이 자체적으로 확보한 네이티브 메모리 영역은 측정 대상에서 제외됩니다. 
그 외에도 IL2CPP 빌드의 경우, IL2CPP의 메타데이터(100MB 정도)도 측정 대상에서 제외됩니다. 
반면 네이티브 툴인 Xcode의 경우, 앱에서 확보한 메모리는 모두 측정됩니다. 
따라서 보다 정확한 값이 측정되는 네이티브 호환 툴을 사용하는 것이 좋다. 

//image[xcode_debug_memory][Xcode Debug Navigator]

====[/column]

==={start_ready_low_spec} 동작 보장 단말기 결정
성능 튜닝을 어디까지 할 것인지를 결정하는 지표로 최소한의 동작을 보장하는 단말기를 결정하는 것도 중요합니다. 
이 동작 보장 단말의 선정은 경험이 없으면 바로 결정하기 어렵지만, 섣불리 결정하지 말고 우선 저사양 단말의 후보를 찾아내는 것부터 시작하자. 

필자가 추천하는 방법은 'SoC의 스펙'을 측정한 데이터를 참고하는 방법입니다. 
구체적으로는 벤치마크 측정 앱으로 측정된 데이터를 웹에서 찾아봅니다. 
우선 기준 단말기의 스펙을 파악하고, 그보다 다소 낮은 측정값을 가진 단말기를 몇 가지 패턴으로 선정해 봅시다. 

단말기가 선정되면 실제로 애플리케이션을 설치하여 동작을 확인합니다. 
동작이 무겁다고 해서 낙담하지 마세요. 이제야 비로소 무엇을 제거할 것인지 논의할 수 있는 출발선에 섰습니다. 
다음 항목에서는 기능을 깎아낼 때 고려해야 할 중요한 사양에 대해 소개합니다. 

//info{
벤치마크 측정 앱은 여러 가지가 있지만, 필자는 Antutu를 기준으로 삼았습니다. 
측정 데이터를 모아놓은 사이트( 
)가 존재하고, 자원봉사자들도 적극적으로 측정 데이터를 보고해주고 있기 때문입니다. 
//}

==={start_ready_quality_setting} 품질 설정의 사양을 정한다
시장에 다양한 사양의 단말기가 넘쳐나는 지금, 한 가지 사양으로 많은 단말기를 커버하기란 쉽지 않다. 
그래서 최근에는 게임 내에 몇 가지 품질 설정을 설정해 다양한 단말기에서 안정적인 동작을 보장하는 것이 대세다. 

예를 들어 다음과 같은 항목을 고, 중, 저 품질 설정으로 구분하는 것이 좋습니다. 

 * 화면 해상도
 * 오브젝트 표시 수
 * 그림자 유무
 * 포스트 이펙트 기능
 * 프레임 속도
 * CPU 부하가 높은 스크립트 건너뛰기 기능 등

단, 외형적인 퀄리티를 떨어뜨리게 되므로 감독과 상의하여 
프로젝트에서 어느 선까지 허용할 수 있는지를 함께 고민해 보시기 바랍니다. 

=={start_detect_degration} 미연에 방지
성능 저하는 버그와 마찬가지로 시간이 지날수록 다양한 원인이 얽히고설켜 조사의 난이도가 높아집니다. 
가능한 한 조기에 발견할 수 있는 구조를 애플리케이션에 구현해 놓는 것이 좋습니다. 
구현하기 쉽고 효과적일 수 있는 방법은 화면에 현재 애플리케이션의 상태를 표시하는 것이다. 
적어도 다음 요소는 화면에 항상 표시하는 것을 권장합니다. 

 * 현재 프레임 속도
 * 현재 메모리 사용량

//image[performance_stats][성능 시각화]

프레임 속도는 체감상 성능 저하를 알 수 있지만, 메모리는 충돌이 발생해야만 감지할 수 있습니다. 
@<img>{performance_stats}와 같이 항상 화면에 표시해두면 메모리 누수를 조기에 발견할 수 있는 확률이 높아집니다. 

이 표시 방법은 조금 더 응용하면 더욱 효과적입니다. 
예를 들어 프레임 속도 목표가 30프레임이라면 25~30프레임은 녹색, 20~25프레임은 노란색, 그 이하는 빨간색으로 표시해 보자. 
이렇게 하면 직관적으로 애플리케이션이 기준을 충족하는지 한 눈에 알 수 있습니다. 

=={start_tuning} 성능 튜닝을 위한 노력
아무리 성능 저하를 방지하려고 노력해도, 모든 것을 방지하는 것은 쉽지 않을 것이다. 
이는 어쩔 수 없는 일이다. 개발을 진행하면서 성능 저하는 떼려야 뗄 수 없는 관계입니다. 성능 튜닝과 마주할 때가 반드시 올 것이다. 
다음 글에서는 성능 튜닝을 어떻게 접근해야 하는지에 대해 설명하겠습니다. 

==={start_tuning_attitude} 마음가짐
성능 튜닝을 시작하기 전에 먼저 중요한 마음가짐을 소개합니다. 
예를 들어, 프레임 속도가 저하되는 애플리케이션이 있다고 가정해 봅시다. 분명히 리치 모델이 여러 개 표시되고 있습니다. 
주변 사람들은 이 모델이 원인일 거라고 말한다. 
정말 그럴까, 그 증거는 어디에 있는지 잘 살펴볼 필요가 있다. 
성능 튜닝을 할 때 반드시 염두에 두어야 할 두 가지가 있다. 

첫 번째는 @<em>{측정하고} 원인을 파악하는 것입니다. 추측해서는 @<em>{안 됩니다}. 

두 번째는 튜닝을 한 후에는 반드시 @<em>{결과를 비교해야} 합니다. 전후의 프로파일을 비교하는 것이 좋습니다. 
중요한 것은 수정한 부분뿐만 아니라 전체적으로 성능 저하가 발생하지 않았는지 확인해야 한다는 것입니다. 
성능 튜닝의 무서운 점은 수정한 부분은 빨라졌지만 다른 부분에서 부하가 증가해 전체적으로는 성능이 저하되는 경우가 드물게 발생한다는 것입니다. 
이는 본말이 전도된 것입니다. 

//image[tuning_basic_flow][성능 튜닝의 마음가짐]
확실하게 원인을 찾아내고 확실하게 빨라진 것을 확인한다. 이것이 성능 튜닝의 중요한 마음가짐입니다. 

==={start_tuning_any_degration} 성능저하의 종류
성능저하라고 해도 각각이 가리키는 것은 다를 수 있습니다. 
이 책에서는 크게 3가지로 구분하여 정의합니다. ( @<img>{degration}) 
//image[degration][성능저하의 원인]

먼저 크래시가 발생하는 경우는 크게 @<em>{'메모리 초과'} 와 @<em>{'프로그램 실행 오류} '의 두 가지로 나눌 수 있습니다. 
후자에 대해서는 성능 튜닝의 영역이 아니기 때문에 구체적인 내용은 본 문서에서 다루지 않습니다. 

다음으로 화면이 느려지거나 로딩이 오래 걸리는 것은 @<em>{'CPU나 GPU의 처리 시간'이} 대부분을 차지할 것입니다. 
이후부터는 '메모리'와 '처리 시간'에 초점을 맞춰 성능 저하를 심층적으로 다룰 것입니다. 

=={start_memory} 메모리 초과 원인 구분
앞서 크래시의 원인으로 메모리 초과를 꼽았습니다. 
이제부터는 메모리 초과 원인을 좀 더 세분화해 보겠습니다. 

==={start_memory_leak} 메모리 누수
메모리 초과 원인 중 하나로 메모리 누수를 꼽을 수 있습니다. 
이를 확인하기 위해 장면 전환에 따라 메모리 사용량이 점차 증가하는지 확인해보겠습니다. 
여기서 말하는 장면 전환은 단순한 화면 전환이 아니라 크게 화면이 전환되는 것을 말합니다. 
예를 들어 타이틀 화면에서 아웃게임, 아웃게임에서 인게임 등으로 전환하는 것을 말합니다. 
측정할 때는 다음과 같은 방법으로 진행합니다. 

 1. 한 장면의 메모리 사용량을 메모한다
 2. 다른 장면으로 전환한다
 3. '1'~'2'의 흐름을 3~5회 정도 반복한다

측정 결과, 메모리 사용량이 순증한다면 분명 무언가 누수되고 있는 것이다. 
이것은 눈에 보이지 않는 결함이라고 할 수 있습니다. 우선은 누수를 없애야 합니다. 

또한 '2'의 트랜지션을 수행하기 전에 몇 개의 화면 전환을 끼워 넣는 것도 좋습니다. 
왜냐하면 특정 화면에서 로드한 리소스만 예외적으로 누수가 발생했을 가능성도 있기 때문입니다. 

리소스 유출이 확실하다면 유출의 원인을 찾아보자. 
@<hd>{start_leak_survey} 에서 구체적인 조사 방법에 대해 설명합니다. 

====[column] 반복하는 이유 

필자의 경험담이지만, 리소스 해제 후(UnloadUnusedAssets 후) 
타이밍 문제로 일부 리소스가 해제되지 않은 경우가 있었습니다. 
이 해제되지 않은 리소스는 다음 장면으로 넘어가면 해제됩니다. 
이에 반해, 트랜지션이 반복될 때 메모리 사용량이 점차 증가하면 결국 크래시가 발생하게 됩니다. 
전자의 문제와 구분하기 위해 이 책에서는 메모리 측정 시 트랜지션을 여러 번 반복하는 방법을 권장하고 있습니다. 

참고로 전자와 같은 문제가 발생한다면, 자원을 해제할 때 어떤 객체가 여전히 참조를 잡고 있다가 해제된 것일 수 있습니다. 
치명적이지는 않지만, 원인 조사를 통해 해결해 두는 것이 좋습니다. 

====[/column]

==={start_memory_large_used} 메모리 사용량이 단순히 많다
유출되지 않은 상태에서 메모리 사용량이 많은 경우, 줄일 수 있는 부분을 찾아봐야 합니다. 
@<hd>{start_memory_reduction} 에서 구체적인 방법을 설명합니다. 

=={start_leak_survey} 메모리 누수 조사하기
먼저 메모리 누수를 재현시킨 후, 다음 소개할 툴을 통해 원인을 찾아보자. 
여기서는 간단하게 도구의 특징을 설명하겠습니다. 
도구 사용법에 대한 자세한 내용은 @<chapref>{profile_tool}에서 다루고 있으니 참고하여 조사해 보시기 바랍니다. 

===={start_leak_survey_unity_memory} Profiler (Memory)
Unity 에디터에 기본적으로 탑재되어 있는 프로파일러 툴입니다. 
따라서 손쉽게 측정할 수 있습니다. 기본적으로 'Detailed'와 'Gather object references'를 설정한 상태에서 메모리를 스냅샷으로 찍어 조사하게 됩니다. 
이 도구로 측정한 데이터는 다른 도구와 달리 스냅샷 비교는 불가능합니다. 
자세한 사용법은 @<hd>{profile_tool|memory_module_unity_prfoiler}에서 확인할 수 있다. 

===={start_leak_survey_memory_profiler} Memory Profiler
이 도구는 Package Manager에서 설치해야 합니다. 
트리맵에서 메모리 내용을 그래픽으로 표시해줍니다. 
유니티 공식에서 지원하며, 현재도 자주 업데이트되고 있다. 
v0.5부터는 참조 관계를 추적하는 방법이 크게 개선되었으므로 최신 버전 사용을 권장합니다. 
자세한 사용법은 @<hd>{profile_tool|tool_memory_profiler}에서 확인할 수 있다. 

===={start_leak_survey_heap_explorer} Heap Explorer
이 도구는 Package Manager를 통해 설치해야 합니다. 
개인이 개발한 도구이지만, 매우 사용하기 쉽고 동작이 가볍습니다. 
참조 관계를 추적할 때 목록 형태로 볼 수 있어 v0.4 이전 버전의 Memory Profiler의 가려운 곳을 긁어주는 도구이다. 
v0.5 버전의 Memory Profiler를 사용할 수 없을 때 대체 도구로 활용하면 좋다. 
자세한 사용법은 @<hd>{profile_tool|tool_heap_explorer}에서 확인할 수 있다. 

=={start_memory_reduction} 메모리를 줄이자
메모리를 줄이는 포인트는 @<em>{큰 부분부터 줄이는} 것입니다. 
왜냐하면 1KB를 1,000개 깎아도 1MB의 감소에 불과하기 때문입니다. 하지만 10MB의 텍스처를 압축하여 2MB로 만들면 8MB도 줄일 수 있습니다. 
비용 대비 효과를 고려하여 큰 것부터 줄여나가는 것이 좋습니다. 

본 절에서 메모리 절감에 사용하는 도구는 Profiler(Memory)로 이야기를 진행하겠습니다. 
사용해보지 않은 분들은 @<hd>{profile_tool|memory_module_unity_prfoiler}에서 자세한 내용을 확인하시기 바랍니다. 

다음 절에서는 줄일 때 살펴봐야 할 항목에 대해 알아보겠습니다. 

==={start_memory_reduction_asset} Assets
Simple View에서 Assets 관련 항목이 많은 경우, 불필요한 자산이나 메모리 누수 가능성이 있습니다. 
여기서 말하는 Assets 관련은 @<img>{profiler_memory_simple}의 사각형으로 둘러싸인 부분입니다. 
//image[profiler_memory_simple][Assets 관련 항목]
이 경우 조사해야 할 사항은 다음 세 가지입니다. 

===={start_memory_reduction_asset_unused} 불필요한 에셋 조사
불필요한 에셋은 현재 씬에 전혀 필요하지 않은 리소스를 말합니다. 
예를 들어 타이틀 화면에서만 사용하는 BGM이 게임 내에서도 메모리에 상주하고 있는 경우 등이 있습니다. 
우선은 현재 씬에 필요한 것들만 정리해 보세요. 

===={start_memory_reduction_asset_duplicate} 중복 에셋 조사
에셋 번들 대응을 할 때 자주 발생하는 문제입니다. 
애셋 번들의 종속성을 잘 구분하지 않아 같은 애셋이 여러 애셋 번들에 포함되어 있는 상태입니다. 
하지만 의존성을 너무 많이 분리하면 다운로드 파일 수 증가와 파일 배포 비용 증가로 이어질 수 있습니다. 
이 부분은 측정하면서 균형 감각을 길러야 할 것 같습니다. 
에셋 번들에 대한 자세한 내용은 @<hd>{basic|basic_unity_assetbundle}에서 확인할 수 있습니다. 

===={start_memory_reduction_asset_regulation} 규정 체크하기
각 항목에 대한 규정을 준수하고 있는지 검토해 보세요. 
규정이 없는 경우, 메모리를 제대로 추정하지 못했을 가능성이 있으므로 확인해야 합니다. 

예를 들어 텍스처의 경우 다음과 같은 내용을 확인하면 좋습니다. 

 * 크기는 적절한가?
 * 압축 설정이 적절한지
 * MipMap 설정이 적절한가?
 * Read/Write 설정이 적절한지 등

각 에셋별로 주의해야 할 점은 @<chapref>{tuning_practice_asset}을 참고하세요. 

==={start_memory_reduction_gc} GC(Mono)
Simple View에서 GC(Mono)가 많은 경우, 한 번에 큰 GC.Alloc이 발생했을 가능성이 높습니다. 
또는 매 프레임마다 GC.Alloc이 발생하여 메모리가 파편화되어 있을 수 있습니다. 
이로 인해 관리 힙 영역이 불필요하게 확장되고 있을 가능성이 있습니다. 
이 경우 GC.Alloc을 꾸준히 줄여나가야 합니다. 

매니지드 힙에 대한 자세한 내용은 @<hd>{basic|basic_memory}을 참고하세요. 
마찬가지로 GC.Alloc에 대한 자세한 내용은 @<hd>{basic|basic_csharp_stack_heap}에서 다루고 있습니다. 

=====[column] 버전별 표기 차이

2020.2 이상에서는 'GC'로 표기되어 있지만, 2020.1 이하 버전까지는 'Mono'로 표기되어 있습니다. 
둘 다 매니지드 힙의 점유량을 의미합니다. 

=====[/column]

==={start_memory_reduction_other} Other
Detailed View에서 의심스러운 항목이 없는지 확인합니다. 
예를 들어 @<em>{Other} 항목 등은 한 번 열어 조사해보는 것이 좋습니다. 
//image[profiler_memory_other][Other 항목]
필자의 경험으로는 SerializedFile이나 PersistentManager.Remapper가 상당히 부풀려져 있는 경우가 있었다. 
여러 프로젝트에서 수치 비교가 가능하다면 한 번 비교해 보는 것도 좋다. 
각각의 수치를 비교해 보면 이상치를 발견할 수 있을지도 모릅니다. 
자세한 내용은 @<hd>{profile_tool|memory_module_detailed_view}에서 확인할 수 있습니다. 

==={start_memory_reduction_plugin} 플러그인
여기까지는 Unity의 측정 도구를 사용하여 원인을 파악해 왔습니다. 
하지만 Unity에서 측정할 수 있는 것은 Unity가 관리하고 있는 메모리만 측정할 수 있습니다. 
즉, 플러그인에서 자체적으로 확보하고 있는 메모리 양 등은 측정되지 않습니다. 
ThirdParty 제품에서 여분의 메모리를 확보하고 있는 것은 아닌지 살펴봐야 합니다. 

구체적으로는 네이티브 측정 도구(Xcode의 Instruments)를 이용합니다. 
자세한 내용은 @<hd>{profile_tool|tool_instruments}을 참고하세요. 

==={start_memory_reduction_planning} 사양 검토하기
이것은 마지막 수단입니다. 
지금까지 살펴본 내용들로 해결할 수 있는 부분이 없다면, 사양을 검토할 수밖에 없습니다. 
다음은 그 예시입니다. 

 * 텍스처의 압축률 변경하기
 ** 텍스처의 일부분만 압축률을 한 단계 높인다.
 * 로딩/언로딩하는 타이밍을 변경한다.
 ** 상주 메모리에 있는 오브젝트를 해제할 때마다 로드하도록 한다.
 * 로드 사양 변경하기
 ** 인게임에서 로드하는 캐릭터의 종류를 1가지로 줄인다.

모두 영향 범위가 크고, 게임의 재미에 근본적으로 영향을 미칠 수 있습니다. 
따라서 사양 검토는 최후의 수단입니다. 
이를 방지하기 위해 초기에 메모리를 추정하고 측정하는 것이 좋습니다. 

=={start_process_reduction} 버벅거림의 원인 파악
이제부터는 처리 시간을 측정하고 최적화하는 과정을 소개합니다. 
화면의 처리지연은 '순간적인 처리지연'인지 '상시적인 처리지연'인지에 따라 대처 방법이 달라집니다. 

//info{
순간적인 처리지연은 바늘처럼 뾰족한 처리 부하가 측정됩니다. 
그 모양새를 보고 스파이크라고 부르기도 합니다. 
//}

//image[process_heavy][스파이크와 정적 처리량]

@<img>{process_heavy}는 정적 부하가 급격히 증가하고 있고, 주기적으로 스파이크가 발생하는 측정 데이터입니다. 
두 가지 모두 성능 튜닝이 필요할 것입니다. 
먼저 비교적 간단한 순간 부하 조사에 대해 설명하겠습니다. 
그 다음에는 정적 부하 조사에 대해 설명한다. 

=={start_spike} 순간 부하 조사하기
스파이크 조사 방법으로는 Profiler(CPU)를 이용하여 원인을 조사합니다. 

도구의 자세한 사용법은 @<hd>{profile_tool|cpu_module_unity_profiler}을 참고하시기 바랍니다. 
우선 원인이 GC에 의한 것인지 아닌지를 구분합니다. 
원인 규명 자체에는 Deep Profile이 필요하지 않지만, 해결을 위해서는 필요할 것입니다. 

==={start_spike_gc} GC에 의한 스파이크
GC(가비지 콜렉션)가 발생하고 있다면 GC.Alloc을 줄여야 합니다. 
어떤 프로세스가 얼마나 많이 할당하고 있는지는 Deep Profile을 이용하면 좋다. 
우선적으로 줄여야 할 부분은 비용 효율성이 높은 부분입니다. 
다음 항목들을 중심으로 수정하는 것이 좋습니다. 

 * 매 프레임마다 할당하는 부분
 * 대량의 할당량이 발생하는 부분

할당량은 적을수록 좋지만, 반드시 제로가 되어야 한다는 의미는 아닙니다. 
예를 들어 생성 처리(Instantiate) 등에서 발생하는 할당량은 막을 수 없을 것이다. 
이럴 때는 매번 객체를 생성하지 않고 객체를 돌려가며 사용하는 풀링(Pooling)과 같은 방법이 효과적입니다. 
GC에 대한 자세한 내용은 @<hd>{basic|basic_csharp_gc}에서 확인할 수 있습니다. 

==={start_spike_heavy_process} 과부하로 인한 스파이크
GC가 원인이 아니라면 어떤 무거운 처리가 순간적으로 이루어지고 있습니다. 
이 경우에도 Deep Profile을 이용하여 어떤 처리가 얼마나 무거운지 조사하고, 가장 많은 시간이 소요되는 부분을 점검해 보도록 하자. 

흔히 볼 수 있는 일시적으로 무거운 처리라고 하면 다음과 같은 것들을 생각해 볼 수 있습니다. 

 * Instantiate 처리
 * 대량의 오브젝트 또는 계층 구조가 깊은 오브젝트의 활성 전환
 * 화면 캡처 처리 등

이처럼 프로젝트 코드에 상당히 의존하는 부분이기 때문에 해결 방법은 일률적으로 이렇게 하면 된다라는 것은 없습니다. 
실제로 측정하여 원인을 파악한 후 프로젝트 구성원들에게 측정 결과를 공유하고, 어떻게 개선해야 할지 고민해 보시기 바랍니다. 

=={start_heavy_process} 정적 부하 조사하기
정적 처리 부하를 개선할 때는 1프레임 내 처리를 어떻게 줄일 수 있느냐가 중요하다. 
1프레임 내에서 이루어지는 처리는 크게 CPU 처리와 GPU 처리로 나눌 수 있습니다. 
우선 이 두 가지 처리 중 어느 쪽이 병목현상이 발생하는지, 아니면 동일한 수준의 처리부하인지 구분하는 것이 좋습니다. 

//info{
CPU에 병목현상이 있는 상태를 CPU 바운드, GPU에 병목현상이 있는 상태를 GPU 바운드라고 합니다. 
//}

쉽게 구분하는 방법으로는 다음과 같은 내용이 해당된다면 GPU 바운드일 가능성이 높습니다. 

 * 화면 해상도를 낮췄을 때 처리 부하가 극적으로 개선된다.
 * Profiler로 측정했을 때@<kw>{Gfx.WaitForPresent} 가 존재함

반대로 이것들이 없다면 CPU 바운드일 가능성이 있습니다. 
다음에서는 CPU 바운드와 GPU 바운드를 조사하는 방법에 대해 설명합니다. 

==={start_heavy_process_cpu} CPU 바운드
CPU 바운드는 지난 절에서 다루었던 CPU (Profiler)를 이용합니다. 
Deep Profile을 이용하여 조사하고, 특정 알고리즘에 큰 처리 부하가 걸리지 않는지 확인합니다. 
큰 처리 부하가 없다면 균등하게 무겁다는 의미이므로 꾸준히 개선해 나갑니다. 
꾸준한 개선에도 불구하고 목표한 감소량에 미치지 못한다면 
@<hd>{start_ready_quality_setting} 로 돌아가서 다시 생각해보는 것도 좋다. 

==={start_heavy_process_gpu} GPU 바운드
GPU 바운드의 경우 Frame Debugger를 이용해 조사하는 것이 좋습니다. 
자세한 사용법은 @<hd>{profile_tool|tool_frame_debugger}에서 확인할 수 있다. 

===={start_heavy_process_gpu_resolution} 해상도가 적절한지
GPU 바운드 중에서도 해상도는 GPU의 처리량에 큰 영향을 미칩니다. 
따라서 해상도를 적절하게 설정하지 않은 상태라면 우선적으로 적절한 해상도를 설정하는 것이 최우선입니다. 

먼저, 예상 품질 설정에서 적절한 해상도가 설정되어 있는지 확인합니다. 
확인 방법은 Frame Debugger 내에서 처리하고 있는 렌더 타깃의 해상도에 주목하는 것이 좋습니다. 
만약 의도적으로 다음 사항을 구현하지 않았다면 최적화 작업을 진행해야 합니다. 

 * UI 요소만 디바이스의 전체 해상도로 렌더링되고 있다.
 * 포스트 이펙트를 위한 임시 텍스처의 해상도가 높은 경우 등

===={start_heavy_process_gpu_unused} 불필요한 오브젝트 존재 여부
Frame Debugger에서 불필요한 드로잉이 없는지 확인합니다. 
예를 들어, 필요 없는 카메라가 활성화되어 있고, 뒤에서 관련 없는 드로잉이 이루어지고 있을 수 있습니다. 
또한, 다른 차폐물로 인해 직전의 드로잉이 낭비되는 경우가 많은 경우,@<kw>{오클루전 컬링} 을 고려하는 것도 좋습니다. 
오클루전 컬링에 대한 자세한 내용은 @<hd>{tuning_practice_graphics|practice_graphics_occlusion_culling}에서 확인할 수 있습니다. 

//info{
오클루전 컬링은 데이터를 미리 준비해야 하고, 그 데이터를 메모리에 전개하기 때문에 메모리 사용량이 증가한다는 점도 주의해야 합니다. 
이처럼 성능을 향상시키기 위해 미리 준비된 정보를 메모리에 구축하는 것은 흔한 방법이다. 
메모리와 성능은 반비례하는 경우가 많기 때문에, 무언가를 채택할 때는 메모리도 염두에 두는 것이 좋다. 
//}

===={start_heavy_process_gpu_batching} 배칭이 적절한지
그리기 대상을 한꺼번에 그리는 것을 일괄적으로 그리는 것을 배치라고 합니다. 
한꺼번에 그려짐으로써 그리기 효율이 높아지기 때문에 GPU 바운딩에 효과가 있습니다. 
예를 들어 Static Batching을 이용하면 여러 개의 움직이지 않는 오브젝트의 메시를 묶어줍니다. 

배칭에 관해서는 여러 가지 방법이 있는데, 대표적인 몇 가지를 소개합니다. 
궁금하신 것이 있다면 @<hd>{tuning_practice_graphics|practice_graphics_draw_call}를 참고해 보세요. 

 * Static Batching
 * Dynamic Batching
 * GPU 인스턴싱
 * SRP Batcher 등

===={start_heavy_process_gpu_any} 개별적으로 부하 살펴보기
그래도 처리 부하가 높다면 개별적으로 살펴볼 수밖에 없습니다. 
오브젝트의 버텍스 수가 너무 많거나, Shader의 처리에 원인이 있을 수 있습니다. 
이를 구분하기 위해서는 개별 오브젝트에 대해 액티브 전환을 해보고, 처리 부하가 어떻게 변하는지 살펴봐야 합니다. 
구체적으로 배경을 지우면 어떻게 되는지, 캐릭터를 지우면 어떻게 되는지 등 카테고리별로 세분화합니다. 
처리량이 많은 카테고리를 파악했다면, 다음과 같은 요소를 추가로 살펴보는 것이 좋습니다. 

 * 그리는 오브젝트가 너무 많은지
 ** 한꺼번에 그릴 수 없는지 검토한다.
 * 1 오브젝트의 버텍스 수가 너무 많지는 않은지
 ** 리덕션, LOD를 고려한다
 * 간단한 Shader로 대체하여 처리 부하가 개선될까?
 ** Shader 처리 재검토

===={start_heavy_process_gpu_others} 그 외
각각의 GPU 처리가 쌓여서 무겁다고 할 수 있습니다. 
이 경우 꾸준히 하나씩 개선해 나가는 수밖에 없습니다. 

또한 이 역시 CPU 바운드와 마찬가지로, 목표 절감치에 미치지 못한다면 
@<hd>{start_ready_quality_setting} 로 돌아가서 다시 생각해보는 것도 좋습니다. 

=={start_summary} 마무리
이 장에서는 '성능 튜닝 전'과 '성능 튜닝 중'에 주의해야 할 사항을 다루었습니다. 

성능 튜닝 전에 주의해야 할 사항은 다음과 같습니다. 

 * '지표', '동작 보증 단말기', '품질 설정 사양'을 정한다.
 ** 양산 전까지 검증을 통해 지표를 확정할 것.
 * 성능 저하를 쉽게 알아차릴 수 있는 구조를 만들어야 한다.

성능 튜닝 시 주의해야 할 사항은 다음과 같다. 

 * 성능 저하의 원인을 파악하고 적절한 대응을 해야 한다.
 * '측정', '개선', '재측정(결과 확인)'의 일련의 흐름을 반드시 수행해야 한다.

성능 튜닝은 지금까지 설명한 바와 같이 측정하여 원인을 파악하는 것이 중요합니다. 
이 문서에 언급되지 않은 사례가 발생하더라도 그 기본이 지켜진다면 큰 문제가 되지 않을 것이다. 
성능 튜닝을 한 번도 해본 적이 없는 분들은 이 장의 내용을 꼭 실천해 보시기 바랍니다. 
